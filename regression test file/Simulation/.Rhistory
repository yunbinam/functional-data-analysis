norm.theta <- 1/(t(theta)%*%D%*%theta) * theta
1/(t(theta)%*%D%*%theta)
as.integer(1/(t(theta)%*%D%*%theta))
as.numas.numeric(1/(t(theta)%*%D%*%theta))
as.numeric(1/(t(theta)%*%D%*%theta))
norm.theta <- as.numeric(1/(t(theta)%*%D%*%theta)) * theta
t(norm.theta) %*% D %*% norm.theta
norm.theta
theta
D
as.numeric(1/(t(theta)%*%D%*%theta))
as.numeric(1/(t(norm.theta)%*%D%*%norm.theta))
t(norm.theta)%*%D%*%norm.theta)
t(norm.theta)%*%D%*%norm.theta
norm.theta
t(theta)%*%D%*%theta
1/(t(theta)%*%D%*%theta)
norm.theta <- as.numeric(1/(t(theta)%*%D%*%theta)) * (diag(K) - Q%*%t(Q)%*%D) %*% random.theta
norm.theta
as.numeric(1/(t(theta)%*%D%*%theta))
as.numeric(t(theta)%*%D%*%theta)
theta <- (diag(K) - Q%*%t(Q)%*%D) %*% (2*random.theta)
as.numeric(t(theta)%*%D%*%theta)
theta <- (diag(K) - Q%*%t(Q)%*%D) %*% (4*random.theta)
as.numeric(t(theta)%*%D%*%theta)
as.numeric(t(theta)%*%D%*%theta) / (diag(K) - Q%*%t(Q)%*%D) %*% (2*random.theta)
as.numeric(t(theta)%*%D%*%theta) / as.numeric((diag(K) - Q%*%t(Q)%*%D) %*% (2*random.theta))
0.7172/0.1792
0.04482584 *22
theta <- (diag(K) - Q%*%t(Q)%*%D) %*% random.theta
norm <- as.numeric(t(theta)%*%D%*%theta)
norm
theta
sqrt(1/norm)
norm.theta <- theta * sqrt(1/norm)
as.numeric(t(norm.theta)%*%D%*%norm.theta)
r <- nrow(eigV)
c <- ncol(eigV)
# pick an eigenfunction as beta
beta <- matrix(eigV[, sample(1:c,1)], ncol=1) # r by 1 vector
X <- matrix(0, nrow=n, ncol=r) # n samples by r nodes
Y <- as.matrix(Y)
X <- as.matrix(X)
n <- nrow(Y)
K <- ncol(Y)
s <- ncol(X)
## 1. prepare matrix D
D <- 1/n * (t(Y)%*%Y) # K by K matrix
## 3. pre-specify theta1
Q <- as.matrix(rep(1, ncol(Y)))
## 4. loop
## a. compute theta
random.theta <- runif(K)
theta <- (diag(K) - Q%*%t(Q)%*%D) %*% random.theta
norm <- as.numeric(t(theta)%*%D%*%theta)
norm.theta <- theta * sqrt(1/norm)
R0til.inv <- Matrix::Diagonal(x=1/Matrix::rowSums(R0))
L <- R1 %*% R0til.inv %*% R1
S <- chol(L)
X.star <- rbind(X, sqrt(lambda)*t(S))
mapped.Y <- Y %*% norm.theta
lambda=1
R0til.inv <- Matrix::Diagonal(x=1/Matrix::rowSums(R0))
L <- R1 %*% R0til.inv %*% R1
S <- chol(L)
X.star <- rbind(X, sqrt(lambda)*t(S))
mapped.Y <- Y %*% norm.theta
rm(list=ls())
Y <- matrix(c(0,1,0,
1,0,0,
1,0,0,
0,0,1,
0,0,1,
1,0,0,
0,1,0), ncol=3, byrow=TRUE)
X <- matrix(runif(7*642), ncol=642)
R0 <- readMM('../R0_642.mtx')
R1 <- readMM('../R1_642.mtx')
lambda <- 1
Y <- as.matrix(Y)
X <- as.matrix(X)
n <- nrow(Y)
K <- ncol(Y)
s <- ncol(X)
## 1. prepare matrix D
D <- 1/n * (t(Y)%*%Y) # K by K matrix
## 3. pre-specify theta1
Q <- as.matrix(rep(1, ncol(Y)))
random.theta <- runif(K)
theta <- (diag(K) - Q%*%t(Q)%*%D) %*% random.theta
norm <- as.numeric(t(theta)%*%D%*%theta)
norm.theta <- theta * sqrt(1/norm)
R0til.inv <- Matrix::Diagonal(x=1/Matrix::rowSums(R0))
L <- R1 %*% R0til.inv %*% R1
S <- chol(L)
X.star <- rbind(X, sqrt(lambda)*t(S))
mapped.Y <- Y %*% norm.theta
Y.star <- c(mapped.Y, rep(0, s))
centered.X.star <- X.star - mean(X.star)
centered.Y.star <- Y.star - mean(Y.star)
mean(centered.X.star)
mapped.Y
beta <- glmnet(centered.X.star, centered.Y.star,
lambda=0, alpha=0, intercept=FALSE, standardize=FALSE,
thresh=1e-7)$beta
glmnet::glmnet(centered.X.star, centered.Y.star,
lambda=0, alpha=0, intercept=FALSE, standardize=FALSE,
thresh=1e-7)$beta
beta <- glmnet::glmnet(centered.X.star, centered.Y.star,
lambda=0, alpha=0, intercept=FALSE,
standardize=FALSE, thresh=1e-7)$beta
inv(D)
inverse(D)
solve(D)
D
1/D
D
solve(D)
new.theta <- (diag(K) - Q%*%t(Q)%*%D) %*% solve(D) %*% t(Y) %*% X %*% beta
new.theta
new.theta <- (diag(K) - Q%*%t(Q)%*%D) %*% solve(D)%*%t(Y)%*%X%*%beta
new.norm <- as.numeric(t(new.theta)%*%D%*%new.theta)
new.norm.theta <- new.theta * sqrt(1/new.norm)
new.norm.theta
as.numeric(t(new.norm.theta)%*%D%*%new.norm.theta)
new.theta <- (diag(K) - Q%*%t(Q)%*%D) %*% solve(D)%*%t(Y)%*%X%*%beta
new.norm <- as.numeric(t(new.theta)%*%D%*%new.theta)
new.norm.theta <- new.theta * sqrt(1/new.norm)
Q <- cbind(Q, new.norm.theta)
Q
rm(list=ls())
Y <- matrix(c(0,1,0,
1,0,0,
1,0,0,
0,0,1,
0,0,1,
1,0,0,
0,1,0), ncol=3, byrow=TRUE)
X <- matrix(runif(7*642), ncol=642)
R0 <- readMM('../R0_642.mtx')
R1 <- readMM('../R1_642.mtx')
lambda <- 1
Y <- as.matrix(Y)
X <- as.matrix(X)
n <- nrow(Y)
K <- ncol(Y)
s <- ncol(X)
## 1. prepare matrix D
D <- 1/n * (t(Y)%*%Y) # K by K matrix
## 3. pre-specify theta1
Q <- as.matrix(rep(1, ncol(Y)))
## 4. loop
for(i in 1:(K-1)){
## a. compute theta
random.theta <- runif(K)
theta <- (diag(K) - Q%*%t(Q)%*%D) %*% random.theta
norm <- as.numeric(t(theta)%*%D%*%theta)
norm.theta <- theta * sqrt(1/norm)
## b. solve beta
R0til.inv <- Matrix::Diagonal(x=1/Matrix::rowSums(R0))
L <- R1 %*% R0til.inv %*% R1
S <- chol(L)
X.star <- rbind(X, sqrt(lambda)*t(S))
mapped.Y <- Y %*% norm.theta
Y.star <- c(mapped.Y, rep(0, s))
centered.X.star <- X.star - mean(X.star)
centered.Y.star <- Y.star - mean(Y.star)
beta <- glmnet::glmnet(centered.X.star, centered.Y.star,
lambda=0, alpha=0, intercept=FALSE,
standardize=FALSE, thresh=1e-7)$beta
## c. add new theta
new.theta <- (diag(K) - Q%*%t(Q)%*%D) %*% solve(D)%*%t(Y)%*%X%*%beta
new.norm <- as.numeric(t(new.theta)%*%D%*%new.theta)
new.norm.theta <- new.theta * sqrt(1/new.norm)
Q <- cbind(Q, new.norm.theta)
}
Q
random.theta <- runif(K)
theta <- (diag(K) - Q%*%t(Q)%*%D) %*% random.theta
norm <- as.numeric(t(theta)%*%D%*%theta)
norm.theta <- theta * sqrt(1/norm)
Q <- as.matrix(rep(1, ncol(Y)))
Q[1,]
Q
Q[,1]
as.matrix(Q[,1])
rm(list=ls())
## simple example
Y <- matrix(c(0,1,0,
1,0,0,
1,0,0,
0,0,1,
0,0,1,
1,0,0,
0,1,0), ncol=3, byrow=TRUE)
X <- matrix(runif(7*642), ncol=642)
R0 <- readMM('../R0_642.mtx')
R1 <- readMM('../R1_642.mtx')
lambda <- 1
Y <- as.matrix(Y)
X <- as.matrix(X)
n <- nrow(Y)
K <- ncol(Y)
s <- ncol(X)
## 1. prepare matrix D
D <- 1/n * (t(Y)%*%Y) # K by K matrix
## 3. pre-specify theta1
Q <- as.matrix(rep(1, ncol(Y)))
for(i in 1:(K-1)){
## a. compute theta
random.theta <- runif(K)
theta <- (diag(K) - as.matrix(Q[,i])%*%t(as.matrix(Q[,i]))%*%D) %*% random.theta
norm <- as.numeric(t(theta)%*%D%*%theta)
norm.theta <- theta * sqrt(1/norm)
## b. solve beta
R0til.inv <- Matrix::Diagonal(x=1/Matrix::rowSums(R0))
L <- R1 %*% R0til.inv %*% R1
S <- chol(L)
X.star <- rbind(X, sqrt(lambda)*t(S))
mapped.Y <- Y %*% norm.theta
Y.star <- c(mapped.Y, rep(0, s))
centered.X.star <- X.star - mean(X.star)
centered.Y.star <- Y.star - mean(Y.star)
beta <- glmnet::glmnet(centered.X.star, centered.Y.star,
lambda=0, alpha=0, intercept=FALSE,
standardize=FALSE, thresh=1e-7)$beta
## c. add new theta
new.theta <- (diag(K) - as.matrix(Q[,i])%*%t(as.matrix(Q[,i]))%*%D) %*% solve(D)%*%t(Y)%*%X%*%beta
new.norm <- as.numeric(t(new.theta)%*%D%*%new.theta)
new.norm.theta <- new.theta * sqrt(1/new.norm)
Q <- cbind(Q, new.norm.theta)
}
Q
predicted.scores <- as.matrix(rep(0, s*(K-1)))
predicted.scores
str(predicted.scores)
predicted.scores <- as.matrix(rep(0, s*(K-1)), ncol=K-1)
str(predicted.scores)
predicted.scores <- matrix(rep(0, s*(K-1)), ncol=K-1)
str(predict)
str(predicted.scores)
rm(list=ls())
## simple example
Y <- matrix(c(0,1,0,
1,0,0,
1,0,0,
0,0,1,
0,0,1,
1,0,0,
0,1,0), ncol=3, byrow=TRUE)
X <- matrix(runif(7*642), ncol=642)
R0 <- readMM('../R0_642.mtx')
R1 <- readMM('../R1_642.mtx')
lambda <- 1
Y <- as.matrix(Y)
X <- as.matrix(X)
n <- nrow(Y)
K <- ncol(Y)
s <- ncol(X)
## 1. prepare matrices
D <- 1/n * (t(Y)%*%Y) # K by K matrix
R0til.inv <- Matrix::Diagonal(x=1/Matrix::rowSums(R0))
L <- R1 %*% R0til.inv %*% R1
S <- chol(L)
X.star <- rbind(X, sqrt(lambda)*t(S))
centered.X.star <- X.star - mean(X.star)
Q <- as.matrix(rep(1, ncol(Y)))
predicted.scores <- matrix(rep(0, s*(K-1)), ncol=K-1)
for(i in 1:(K-1)){
## a. compute theta
random.theta <- runif(K)
theta <- (diag(K) - as.matrix(Q[,i])%*%t(as.matrix(Q[,i]))%*%D) %*% random.theta
norm <- as.numeric(t(theta)%*%D%*%theta)
norm.theta <- theta * sqrt(1/norm)
## b. solve beta
mapped.Y <- Y %*% norm.theta
Y.star <- c(mapped.Y, rep(0, s))
centered.Y.star <- Y.star - mean(Y.star)
beta <- glmnet::glmnet(centered.X.star, centered.Y.star,
lambda=0, alpha=0, intercept=FALSE,
standardize=FALSE, thresh=1e-7)$beta
## predicted scores
predicted.scores[,i] <- centered.X.star %*% beta
## c. add new theta
new.theta <- (diag(K) - as.matrix(Q[,i])%*%t(as.matrix(Q[,i]))%*%D) %*% solve(D)%*%t(Y)%*%X%*%beta
new.norm <- as.numeric(t(new.theta)%*%D%*%new.theta)
new.norm.theta <- new.theta * sqrt(1/new.norm)
Q <- cbind(Q, new.norm.theta)
}
predicted.scores
predicted.scores[,1]
predicted.scores[,1] <- rep(1, 642)
centered.X.star %*% beta
str(centered.X.star %*% beta)
str(beta)
str(centered.X.star)
rm(list=ls())
## simple example
Y <- matrix(c(0,1,0,
1,0,0,
1,0,0,
0,0,1,
0,0,1,
1,0,0,
0,1,0), ncol=3, byrow=TRUE)
X <- matrix(runif(7*642), ncol=642)
R0 <- readMM('../R0_642.mtx')
R1 <- readMM('../R1_642.mtx')
lambda <- 1
Y <- as.matrix(Y)
X <- as.matrix(X)
n <- nrow(Y)
K <- ncol(Y)
s <- ncol(X)
D <- 1/n * (t(Y)%*%Y) # K by K matrix
R0til.inv <- Matrix::Diagonal(x=1/Matrix::rowSums(R0))
L <- R1 %*% R0til.inv %*% R1
S <- chol(L)
centered.X <- X - mean(X)
X.star <- rbind(centered.X, sqrt(lambda)*t(S))
Q <- as.matrix(rep(1, ncol(Y)))
predicted.scores <- matrix(rep(0, s*(K-1)), ncol=K-1)
## 4. loop
for(i in 1:(K-1)){
## a. compute theta
random.theta <- runif(K)
theta <- (diag(K) - as.matrix(Q[,i])%*%t(as.matrix(Q[,i]))%*%D) %*% random.theta
norm <- as.numeric(t(theta)%*%D%*%theta)
norm.theta <- theta * sqrt(1/norm)
## b. solve beta
mapped.Y <- Y %*% norm.theta
centered.mapped.Y <- mapped.Y - mean(mapped.Y)
Y.star <- c(centered.mapped.Y, rep(0, s))
beta <- glmnet::glmnet(X.star, Y.star,
lambda=0, alpha=0, intercept=FALSE,
standardize=FALSE, thresh=1e-7)$beta
## predicted scores
predicted.scores[,i] <- centered.X %*% beta
## c. add new theta
new.theta <- (diag(K) - as.matrix(Q[,i])%*%t(as.matrix(Q[,i]))%*%D) %*% solve(D)%*%t(Y)%*%X%*%beta
new.norm <- as.numeric(t(new.theta)%*%D%*%new.theta)
new.norm.theta <- new.theta * sqrt(1/new.norm)
Q <- cbind(Q, new.norm.theta)
}
str(predicted.scores)
centered.X %*% beta
str(centered.X)
str(beta)
predicted.scores <- matrix(rep(0, n*(K-1)), ncol=K-1)
# Arguments:
# Y:          n by K indicator matrix of classes (response vector)
# X:          n by s design matrix (covariates)
# R0:         s by s symmetric mass matrix
# R1:         s by s symmetric stiffness matrix
# lambda:     tuning parameter of smoothness penalty
# ------------------------------------------------------------------------
# Outputs:
#
## simple example
Y <- matrix(c(0,1,0,
1,0,0,
1,0,0,
0,0,1,
0,0,1,
1,0,0,
0,1,0), ncol=3, byrow=TRUE)
X <- matrix(runif(7*642), ncol=642)
R0 <- readMM('../R0_642.mtx')
R1 <- readMM('../R1_642.mtx')
lambda <- 1
opt.score <- function(Y, X, R0, R1, lambda){
Y <- as.matrix(Y)
X <- as.matrix(X)
n <- nrow(Y)
K <- ncol(Y)
s <- ncol(X)
## 1. prepare matrices
D <- 1/n * (t(Y)%*%Y) # K by K matrix
R0til.inv <- Matrix::Diagonal(x=1/Matrix::rowSums(R0))
L <- R1 %*% R0til.inv %*% R1
S <- chol(L)
centered.X <- X - mean(X)
X.star <- rbind(centered.X, sqrt(lambda)*t(S))
## 3. pre-specify theta1
Q <- as.matrix(rep(1, ncol(Y)))
predicted.scores <- matrix(rep(0, n*(K-1)), ncol=K-1)
## 4. loop
for(i in 1:(K-1)){
## a. compute theta
random.theta <- runif(K)
theta <- (diag(K) - as.matrix(Q[,i])%*%t(as.matrix(Q[,i]))%*%D) %*% random.theta
norm <- as.numeric(t(theta)%*%D%*%theta)
norm.theta <- theta * sqrt(1/norm)
## b. solve beta
mapped.Y <- Y %*% norm.theta
centered.mapped.Y <- mapped.Y - mean(mapped.Y)
Y.star <- c(centered.mapped.Y, rep(0, s))
beta <- glmnet::glmnet(X.star, Y.star,
lambda=0, alpha=0, intercept=FALSE,
standardize=FALSE, thresh=1e-7)$beta
## predicted scores
predicted.scores[,i] <- centered.X %*% beta
## c. add new theta
new.theta <- (diag(K) - as.matrix(Q[,i])%*%t(as.matrix(Q[,i]))%*%D) %*% solve(D)%*%t(Y)%*%X%*%beta
new.norm <- as.numeric(t(new.theta)%*%D%*%new.theta)
new.norm.theta <- new.theta * sqrt(1/new.norm)
Q <- cbind(Q, new.norm.theta)
}
}
Y <- matrix(c(0,1,0,
1,0,0,
1,0,0,
0,0,1,
0,0,1,
1,0,0,
0,1,0), ncol=3, byrow=TRUE)
X <- matrix(runif(7*642), ncol=642)
R0 <- readMM('../R0_642.mtx')
R1 <- readMM('../R1_642.mtx')
lambda <- 1
Y <- as.matrix(Y)
X <- as.matrix(X)
n <- nrow(Y)
K <- ncol(Y)
s <- ncol(X)
## 1. prepare matrices
D <- 1/n * (t(Y)%*%Y) # K by K matrix
R0til.inv <- Matrix::Diagonal(x=1/Matrix::rowSums(R0))
L <- R1 %*% R0til.inv %*% R1
S <- chol(L)
centered.X <- X - mean(X)
X.star <- rbind(centered.X, sqrt(lambda)*t(S))
## 3. pre-specify theta1
Q <- as.matrix(rep(1, ncol(Y)))
predicted.scores <- matrix(rep(0, n*(K-1)), ncol=K-1)
## 4. loop
for(i in 1:(K-1)){
## a. compute theta
random.theta <- runif(K)
theta <- (diag(K) - as.matrix(Q[,i])%*%t(as.matrix(Q[,i]))%*%D) %*% random.theta
norm <- as.numeric(t(theta)%*%D%*%theta)
norm.theta <- theta * sqrt(1/norm)
## b. solve beta
mapped.Y <- Y %*% norm.theta
centered.mapped.Y <- mapped.Y - mean(mapped.Y)
Y.star <- c(centered.mapped.Y, rep(0, s))
beta <- glmnet::glmnet(X.star, Y.star,
lambda=0, alpha=0, intercept=FALSE,
standardize=FALSE, thresh=1e-7)$beta
## predicted scores
predicted.scores[,i] <- centered.X %*% beta
## c. add new theta
new.theta <- (diag(K) - as.matrix(Q[,i])%*%t(as.matrix(Q[,i]))%*%D) %*% solve(D)%*%t(Y)%*%X%*%beta
new.norm <- as.numeric(t(new.theta)%*%D%*%new.theta)
new.norm.theta <- new.theta * sqrt(1/new.norm)
Q <- cbind(Q, new.norm.theta)
}
str(predicted.scores)
predicted.scores[,1]
centered.X %*% beta
as.vector(centered.X %*% beta)
Y <- as.matrix(Y)
X <- as.matrix(X)
n <- nrow(Y)
K <- ncol(Y)
s <- ncol(X)
## 1. prepare matrices
D <- 1/n * (t(Y)%*%Y) # K by K matrix
R0til.inv <- Matrix::Diagonal(x=1/Matrix::rowSums(R0))
L <- R1 %*% R0til.inv %*% R1
S <- chol(L)
centered.X <- X - mean(X)
X.star <- rbind(centered.X, sqrt(lambda)*t(S))
## 3. pre-specify theta1
Q <- as.matrix(rep(1, ncol(Y)))
predicted.scores <- matrix(rep(0, n*(K-1)), ncol=K-1)
## 4. loop
for(i in 1:(K-1)){
## a. compute theta
random.theta <- runif(K)
theta <- (diag(K) - as.matrix(Q[,i])%*%t(as.matrix(Q[,i]))%*%D) %*% random.theta
norm <- as.numeric(t(theta)%*%D%*%theta)
norm.theta <- theta * sqrt(1/norm)
## b. solve beta
mapped.Y <- Y %*% norm.theta
centered.mapped.Y <- mapped.Y - mean(mapped.Y)
Y.star <- c(centered.mapped.Y, rep(0, s))
beta <- glmnet::glmnet(X.star, Y.star,
lambda=0, alpha=0, intercept=FALSE,
standardize=FALSE, thresh=1e-7)$beta
## predicted scores
predicted.scores[,i] <- as.vector(centered.X %*% beta)
## c. add new theta
new.theta <- (diag(K) - as.matrix(Q[,i])%*%t(as.matrix(Q[,i]))%*%D) %*% solve(D)%*%t(Y)%*%X%*%beta
new.norm <- as.numeric(t(new.theta)%*%D%*%new.theta)
new.norm.theta <- new.theta * sqrt(1/new.norm)
Q <- cbind(Q, new.norm.theta)
}
predicted.scores
Q
Q[,2]
Q[3,]
Q[,3]
t(Q[,2])
dot(Q[,2], Q[,3])
Q[,2 * Q[,3]
)
Q[,2] * Q[,3]
geometry::dot
pracma::dot
pracma::dot(Q[,2],Q[,3])
Q
